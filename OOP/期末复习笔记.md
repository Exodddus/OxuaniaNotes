## Overloaded Function

**函数重载**：有时我们既需要一个不带参数的默认构造函数，也可能需要一个或多个接受参数的构造函数来满足不同的初始化需求。可以定义多个同名函数，只要它们的参数列表在类型、数量或顺序上有所不同即可。编译器会根据调用时提供的参数情况，自动选择最匹配的函数版本，并且能够进行适当的自动类型转换。
```cpp
void print(char * str, int width); // #1
void print(double d, int width);   // #2
void print(long l, int width);     // #3
void print(int i, int width);      // #4
void print(char *str);             // #5
print("Pancakes", 15);
print("Syrup");
print(1999.0, 10);
print(1999, 12);
print(1999L, 15);
```

- **委托构造函数**
```cpp
class class_c {
public:
    int max;
    int min;
    int middle;

    class_c(int my_max) {
        max = my_max > 0 ? my_max : 10;
        min = 1;
        middle = (max + min) / 2;
        std::cout << "Delegated to: class_c(int)" << std::endl;
    }

    // 此构造函数委托给 class_c(int)
    class_c(int my_max, int my_min) : class_c(my_max) { // 委托调用
        // max 已经由 class_c(my_max) 初始化
        min = my_min > 0 && my_min < max ? my_min : 1;
        middle = (this->max + this->min) / 2; // 使用 this-> 明确访问成员
        std::cout << "Delegated to: class_c(int, int)" << std::endl;
    }

    // 此构造函数委托给 class_c(int, int)
    class_c(int my_max, int my_min, int my_middle) : class_c(my_max, my_min) { // 委托调用
        // max 和 min 已经由 class_c(my_max, my_min) 初始化
        middle = my_middle < this->max && my_middle > this->min ? my_middle : (this->max + this->min) / 2;
        std::cout << "Called: class_c(int, int, int)" << std::endl;
    }
};
```

**默认参数**

**内联函数**（inline functions): 当编译器处理一个内联函数调用时，它会尝试直接将函数的代码体“**嵌入**”或“**展开**”到调用点，而不是执行常规的函数调用跳转。
```cpp
inline int plusOne(int x);
inline int plusOne(int x) { return ++x; };
```

- 即使没有显式使用 `inline` 关键字，任何在类声明内部定义的成员函数都有被视为内联函数的可能。
- 如果一个（成员）函数被声明为 `inline`（或因定义在类内部而隐式内联），它的定义必须对所有使用它的编译单元可见。因此，这类函数的定义通常放在头文件中。如果内联成员函数在类声明之外定义（例如在同一个头文件中，但在类声明之后），则其定义前也需要加上 `inline` 关键字。
- `inline` 关键字仅仅是对编译器的一个建议；编译器并不一定会采纳这个建议，它可能会根据自己的优化策略来决定是否真的内联一个函数。

## Copying & Moving

**copy Ctor**: copy constructors是一种特殊的构造函数，它定义了如何从同一个类的另一个对象来初始化新对象。典型的函数签名为`className::className(const className& other);`。
- 默认拷贝构造函数对于类中的指针成员只会复制指针的值而不是指针所指向的数据，这样会导致原对象和拷贝后的对象指针成员指向同一块内存区域，即**浅拷贝**。因此如果用户自定义类管理资源的话，必须显式提供拷贝构造函数（及拷贝赋值运算符和析构函数），来实现深拷贝和正确的资源管理。

**Copy Assignments**: 拷贝赋值
`T& T::operator=(const T& other);`

Rule of Five: 如果一个类定义了**析构函数**、**拷贝构造函数**、**拷贝赋值运算符**、**移动构造函数**或**移动赋值运算符**中的任何一个，那么这五者都需要定义或显式的 delete / default。

**Move Ctor**: `ClassName(ClassName&& other) noexcept;`
从源对象“窃取”资源，并将源对象置于一个有效的、但通常是空的或未指定的状态。



## Operator Overloading

限制规则：
1. 不能创建新运算符；
2. 至少有一个操作数是用户定义类型；
3. 保留操作数个数、运算优先级、运算结合性

**友元**

常见原型示例：
1. 算术运算符
	`const T T::operatorX(const T& rhs) const;`
	`const T operatorX(const T& lhs, const T& rhs);`
2. 逻辑/比较运算符
	- 一元：
		`bool T::operator!() const;`
		`bool operator!(const T& operand);`
	- 二元：
		`bool T::operatorX(const T& rhs) const;`
		`bool operatorX(const T& lhs, const T& rhs);`
3. 下标运算符
	通常提供两个版本
		`ValueType& T::operator[](IndexType index);`
		`const ValueType& T::operator[](IndexType index) const;`
4. 前缀/后缀自增 (++obj / obj++)
	前缀：`T& T::operator++();` `T& operator++(T& obj);`
	后缀：`T T::operator++(int);`  `T operator++(T& obj, int);`
5. Stream Operations
```cpp
#include <iostream>
#include <sstream>

class Point {
private:
    int x, y;
public:
    Point(int x_val = 0, int y_val = 0) : x(x_val), y(y_val) {}

    friend std::ostream& operator<<(std::ostream& os, const Point& p);
    friend std::istream& operator>>(std::istream& is, Point& p);
};

std::ostream& operator<<(std::ostream& os, const Point& p) {
    os << "(" << p.x << ", " << p.y << ")";
    return os;
}

std::istream& operator>>(std::istream& is, Point& p) {
    // 假设输入格式为 (x, y) 或 x y
    char delim1, comma, delim2;
    // 尝试读取 (x,y) 格式
    if (is >> delim1 && delim1 == '(' &&
        is >> p.x >> comma && comma == ',' &&
        is >> p.y >> delim2 && delim2 == ')') {
        // 读取成功
    } else {
        if (is.fail()) {
            is.clear(); // 清除错误标志
            // 尝试回退流指针 (如果支持并且有必要)
            // 这里简单地假设可以重新读取
            is >> p.x >> p.y;
        }
    }
    return is;
}

int main() {
    Point p1(1, 2), p2;
    std::cout << "P1: " << p1 << std::endl; // ((cout << "P1: ") << p1) << endl;

    std::cout << "Enter point p2 (e.g., 3 4 or (5,6)): ";
    std::cin >> p2;
    std::cout << "P2 entered: " << p2 << std::endl;
}
```
6. 类型转换运算符
```cpp
class Rational {
private:
    int numerator_;
    int denominator_;
public:
    Rational(int num = 0, int den = 1) : numerator_(num), denominator_(den == 0 ? 1 : den) {}

    // 类型转换运算符：将 Rational 转换为 double
    operator double() const {
        return static_cast<double>(numerator_) / denominator_;
    }
};

int main() {
    Rational r(1, 2);
    double d = r; // 隐式调用 r.operator double()
    std::cout << "d = " << d << std::endl; // 输出 d = 0.5

    double val = 0.5 + r; // r 被转换为 double，然后进行加法
    std::cout << "val = " << val << std::endl; // 输出 val = 1.0
}
```

## Virtual Function
- 虚函数必须是所在类的成员函数，不能是其友元函数，也不能是静态函数。
- 内联函数不能是虚函数，构造函数不能是虚函数；析构函数可以是虚函数。
- **纯虚函数**: 在基类中没有定义，要求派生类中必须定义自己的版本，或声明为纯虚函数。如派生类中定义缺失，仍然为纯虚函数。
```cpp
virtual void show()=0;
```
  - 如果一个类至少有一个纯虚函数，就被称为抽象类。抽象类只能作为其他类的基类，不能建立抽象类对象，只能声明抽象类的指针。

## Constructor
- 默认参数只能在原型声明中指定，不能在定义构造函数时指定
- 在构造函数原型声明中，所有给默认值的参数都必须在不给默认值的参数的右面。
- 对象定义时，若省略构造函数的某个参数的值，则其右面所有参数的值都必须省略，而采用默认值。
- 构造初始化列表的方式与直接赋值的构造方式等价
```cpp
	  Date::Date(int y,int m,int d):year(y),month(m),day(d) {}
```

- 对于列表A* p = new A[2]，delete p只调用p的第一个元素的析构函数，而delete p[]才能正确删除整个列表。

## 继承
- 子类对象赋值给基类对象时会发生**切片**，如`基类对象 = 子类对象;`或`*基类指针 = 子类对象;` 或函数传参时值的传递`void fun(Mammal ma){}`-调用`fun(male)`。
- 基类指针指向子类对象，或基类引用绑定子类对象时，不会发生切片，触发动态绑定。因此实现多态仅有两种合法方式：`Mammal &ref = m;`和`Mammal *ref = &m;`。对于引用`Mammal &ref = m`，`ref`是`m`这个`Male`对象的别名，对应的是同一块内存地址。


## Static
- 一个类中定义的某项静态成员变量由该类的所有对象共享，访问静态成员有两种方式：`A::num`或`a.num`。
- 静态成员函数只能访问静态成员，不能访问该类的普通成员变量或普通成员函数，因为静态成员函数没有`this`指针

## 类型转换
**dynamic_cast**: 
- 仅支持指针、引用的转换，不支持普通变量的转换
- 专门用来做继承体系中基类与子类之间的类型转换
- 会检查能否满足转换要求，如果「源指针 / 引用」实际指向的对象真的是「目标类型」/「目标类型的子类」，才能成功转换
- 基类中必须有至少一个虚函数。

**static_cast**: 在编译阶段完成类型转换，遵循类型兼容规则，但不会自动检查正确性

**const_cast**：只能用来去除或增加变量的const属性，是C++中修改这一属性的唯一合法方式

**reinterpret_cast**: 强行重新解释数据二进制位。


## 杂项
- 成员变量在初始化列表中的初始化顺序，和初始化列表里的书写顺序无关，而是严格按照它们在类中的声明顺序来执行的。
- 注意区分重写override和重载overload
- 如果同时存在template<>函数和未使用template的同名函数重载，调用时先查找未使用template的同名函数
- 在类的定义内部直接实现的成员函数，会被编译器默认视为内联函数