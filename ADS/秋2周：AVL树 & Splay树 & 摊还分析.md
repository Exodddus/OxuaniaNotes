# 1. AVL树

## 1.1 LL & RR

每次插入或删除一个节点后，都要考虑这样的操作是否破坏了树的平衡性

![[AVL的RR.png]]
注意最下方示例中的A不一定是整棵树的根节点，而是第一个满足图示结构条件的节点

## 1.2 LR & RL

![[AVL的LR.png]]
需要转两次，同时操作父节点、子节点、孙节点。先对左子树进行左旋操作，变换子节点与孙节点的位置，再对整棵树做右旋。

## 1.3 删除怎么做？

并不是特别经济
叶节点：直接删除
非叶节点：


# 2. Splay Tree

每访问一个节点后，就将这个节点旋转到根节点的位置上。但是Splay Tree不维护节点的高度 / 平衡因子字段，因此无法保障树的平衡。
从空树开始的$M$次连续操作，最多花费时间为$O(MlogN)$。
这不意味着每次操作时间都在 $O(logN)$ 之内。
![[SplayTree的两种操作.png]]
注意：
1. Zig-zig是先转中间节点，再转X节点。
2. 以上两种方法是基于二叉查找树的，不要和之后基于最小堆的算法弄混


## 3. 摊还分析
