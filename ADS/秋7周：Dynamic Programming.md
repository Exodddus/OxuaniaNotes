> 分治是兄弟之间的合作，动规是父子之间的传承。

什么条件下不能用动规？
决策具有 History-dependency，依赖于之前做出的选择

# 例子

## 1. 上台阶问题

——斐波那契数列计算方法的优化

## 2. 矩阵乘法顺序问题

设 $b_n$ 为计算 $M_1 M_2 ... M_n$ 矩阵乘积的不同方式数量，令 $M_{ij} = M_i...M_j$，则 $M_{1n}=M_1...M_n=M_{1i} M_{i+1,n}$

$b_n=\sum_{i=1}^{n-1}b_i b_{n-i}$，$n>1, b_1 = 1$


![[动规矩阵乘法顺序.png]]


## 3. 最优二叉搜索树

![[最优二叉搜索树.png]]

## 4. 全源最短路径

对于每一对顶点$v_i$，$v_j$，找到两点之间的最短路。


现有假设：对于本问题，$O(N^{3-\epsilon})$的算法不存在。这个假设可以推出现有的对于很多问题的算法都已达到最优解。


## 应用动态规划的条件

1. **最优子结构**
	原问题的最优解是从子问题的最优解构建得到的
	
	>爬楼最小代价问题：
	>给定一个楼梯，你每步可以上1阶或者2阶，每一阶楼梯上都贴有一个非负整数，表示你在该台阶所需要付出的代价。给定一个非负整数数组cost，其中 cost[i] 表示在第 i 个台阶需要付出的代价，cost[0] 为地面（起始点）。请计算最少需要付出多少代价才能到达顶部？
	>状态转移方程：$dp[i]=min(dp[i-1], dp[i-2])+cost[i]$
	```c
	/* 爬楼梯最小代价：动态规划 */
int minCostClimbingStairsDP(int cost[], int costSize) {
    int n = costSize - 1;
    if (n == 1 || n == 2)
        return cost[n];
    // 初始化 dp 表，用于存储子问题的解
    int *dp = calloc(n + 1, sizeof(int));
    // 初始状态：预设最小子问题的解
    dp[1] = cost[1];
    dp[2] = cost[2];
    // 状态转移：从较小子问题逐步求解较大子问题
    for (int i = 3; i <= n; i++) {
        dp[i] = myMin(dp[i - 1], dp[i - 2]) + cost[i];
    }
    int res = dp[n];
    // 释放内存
    free(dp);
    return res;
}
	```
	
2. **无后效性**
	给定一个确定的状态，其未来发展只与当前状态有关，而与过去经历的所有状态无关。
	>如果某些问题需多考虑前面一个状态，可以通过扩展状态定义的方式使问题满足无后效性

3. **子问题重叠**


## 动规解题思路

1. 定义状态，得到dp表
2. 找出最优子结构，推导得到状态转移方程
3. 确定边界条件和状态转移顺序
![[Pasted image 20251112201345.png]]
思考方式：暴力搜索 --> 记忆化搜索（从目标位置开始向前递归，记录各个子问题的解）--> 动态规划（迭代，从边界开始逐层更新子问题的解）--> 空间优化（二维转一维，一维转零维）
```C
/* 最小路径和：动态规划 */
int minPathSumDP(int grid[MAX_SIZE][MAX_SIZE], int n, int m) {
    // 初始化 dp 表
    int **dp = malloc(n * sizeof(int *));
    for (int i = 0; i < n; i++) {
        dp[i] = calloc(m, sizeof(int));
    }
    dp[0][0] = grid[0][0];
    // 状态转移：首行
    for (int j = 1; j < m; j++) {
        dp[0][j] = dp[0][j - 1] + grid[0][j];
    }
    // 状态转移：首列
    for (int i = 1; i < n; i++) {
        dp[i][0] = dp[i - 1][0] + grid[i][0];
    }
    // 状态转移：其余行和列
    for (int i = 1; i < n; i++) {
        for (int j = 1; j < m; j++) {
            dp[i][j] = myMin(dp[i][j - 1], dp[i - 1][j]) + grid[i][j];
        }
    }
    int res = dp[n - 1][m - 1];
    // 释放内存
    for (int i = 0; i < n; i++) {
        free(dp[i]);
    }
    return res;
}
```

## 0-1背包问题

状态定义：当前物品编号 i 和背包容量 c ，记为 [i, c] 。
对应的子问题为前i个物品在容量为c的背包中的最大价值 dp[i, c]。待求解 dp[n, cap]
最大价值 dp[i, c] = 不放入物品 i 和放入物品 i 两种方案中价值更大的那一个。
$dp[i, c] = max(dp[i-1, c], dp[i-1, c-weight[i-1]]+val[i-1])$


## 完全背包问题

不限制物品的选择次数，将物品 i 放入背包后，仍可以从前 i 个物品中选择放入。所以放入物品 i 后仍然停留在状态 i 。

$dp[i, c] = max(dp[i-1, c], dp[i, c-weight[i-1]+val[i-1]])$

## 编辑距离问题

编辑距离，也称 Levenshtein 距离，指两个字符串之间互相转换的最少修改次数，通常用于在信息检索和自然语言处理中度量两个序列的相似度。字符串中的编辑操作分为三种：插入一个字符、删除一个字符、将字符替换为另一个字符。

状态：在 s 和 t 中考虑的第 i 和第 j 个字符，记为 [i, j]
状态 [i, j] 对应的子问题：将 s 的前 i 个字符更改为 t 的前 j 个字符所需要的最少编辑步数。
子问题 dp[i, j] 对应的两个字符串的尾部字符分别设为 s[i-1] 和 t[j-1]，可分为以下三种情况——
1. 在 s[i-1] 后添加 t[j-1]，则剩余子问题 dp[i, j-1]
2. 删除 s[i-1]，则剩余子问题 dp[i-1, j]
3. 将 s[i-1] 替换为 t[j-1]，则剩余子问题 dp[i-1, j-1]
$$dp[i, j] = min(dp[i, j-1], dp[i-1, j], dp[i-1, j-1]) + 1$$

如果 s[i-1] 和 t[j-1] 相同，不用编辑这个字符
$$dp[i,j]=dp[i-1,j-1]$$
